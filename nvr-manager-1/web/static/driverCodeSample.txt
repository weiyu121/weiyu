import random
import struct


# 写代码时注意：
# 0. Python版本为3.9，预安装了pyserial库，其他库可咨询管理员是否安装，有必要的话也可以让管理员额外安装
# 1. 如果在处理数据上报和指令下发时遇到问题，可直接抛继承自Exception的异常，系统会进行捕获
# 2. 实际使用时不要加任何print/logger的输出语句

# 初始化（可选）和释放资源（可选）：
# 由装饰器init和release修饰的函数应该定义驱动的初始化和资源释放功能
# 如初始化函数中打开串口，释放资源函数中关闭串口并回收所有不需要的资源
# 如果设置多个初始化和释放资源函数仅由最后一个函数生效
# 写代码进行测试时为了避免代码因为未定义而报错，可以将下面的注释打开，定义两个没有任何功能的假装饰器，实际使用时需要将其删除：
# def init(func):
#     return func
# def release(func):
#     return func

@init
def driver_init():
    # 修改串口权限，打开串口等...
    pass

@release
def driver_release():
    # 关闭串口等...
    pass

# 上报和下发：
# 由两个装饰器report和command进行修饰，这两个装饰器功能在驱动器代码的上下文定义
# 写代码进行测试时为了避免代码因为未定义而报错，可以将下面的注释打开，定义两个没有任何功能的假装饰器，实际使用时需要将其删除：
# def report(interval, device_id, channel):
#     def deco(func):
#         return func
#     return deco
# def command(device_id, channel):
#     def deco(func):
#         return func
#     return deco

###########
# 数据上报 #
###########

# 上报函数原型如下：
# @report(
#   interval: float=<调用上报函数间隔，每个上报函数都有一个自己的定时器>, 
#   device_id: str=<iot子设备id，标识一个物联网子设备，mqtt上报会使用>, 
#   channel: Union[str, Iterator[str]]=<上报的数据通道，支持一个或多个通道，如果是多个通道则需要上报函数有相应数量的返回值>
# )
# def <上报函数名>() -> Union[Union[dict, bytes], tuple[Union[dict, bytes]]]:  # 意思是支持一个或多个返回值，每个返回值都必须是dict或者bytes对象
#   <获取数据代码>
#   return <通道1数据>(, <通道2数据>...)

# 气象传感器设备每隔0.5s上报一次风速数据和温湿度数据到wind和humiture通道
# mqtt topic
#   zzuiot平台：g_events/<板子Secret>/<上报通道>/<物联网子设备ID>
#       g_events/<板子Secret>/wind/meteorology_sensor
#       g_events/<板子Secret>/humiture/meteorology_sensor
#   第三方平台：zzu/aiedge/<板子ID>/iot/<物联网子设备ID>/report/<上报通道>
#       zzu/aiedge/<板子ID>/iot/meteorology_sensor/report/wind
#       zzu/aiedge/<板子ID>/iot/meteorology_sensor/report/humiture
# 由于一个函数要上报两个不同通道，因此应该写两个返回值一一对应两个不同的通道
@report(interval=0.5, device_id='meteorology_sensor', channel=['wind', 'humiture'])
def report_meteorology_sensor_data():
    return {
        'wind_direction': random.choice(['up', 'down', 'left', 'right']),  # 模拟风向数据
        'wind_speed': random.random() * 500  # 模拟风速数据
    }, {
        'temperature': random.random() * 10 + 10,  # 模拟温度
        'humidity': random.random() * 20 + 30  # 模拟湿度
    }

# 气象传感器设备每隔5s上报一次运行状况到status通道
# 和上面那个函数使用的不是一个定时器
# mqtt topic
#   zzuiot平台：g_events/<板子Secret>/status/wind_sensor
#   第三方平台：zzu/aiedge/<板子ID>/iot/wind_sensor/report/status
@report(interval=5, device_id='meteorology_sensor', channel='status')
def report_meteorology_sensor_status():
    return {
        'ok': True,  # 模拟运行没问题
        'message': '系统一切正常'  # 模拟运行没问题
    }

# 红外测距传感器设备每隔1s上报一次字节数据到distance通道（这里只是为了演示可以上报字节数据），此时需要返回bytes字节对象而非字典
# 注意：如果要在一个函数里分别上报字典和字节流到两个不同的通道上也是支持的
# mqtt topic
#   zzuiot平台：g_events/<板子Secret>/distance/infrared_distance_sensor
#   第三方平台：zzu/aiedge/<板子ID>/iot/infrared_distance_sensor/report/distance
@report(interval=1, device_id='infrared_distance_sensor', channel='distance')
def report_infrared_distance_sensor_data():
    return struct.pack('ii', random.randint(0, 5), random.randint(5, 10))

###########
# 指令下发 #
###########

# 指令下发函数原型如下：
# @command(
#   device_id: str=<iot子设备id，标识一个物联网子设备，mqtt下发会使用>, 
#   channel: str=<下发指令的数据通道>
# )
# 如果指令执行失败，直接抛继承自Exception的异常，异常对象中存储错误信息，如果执行成功函数正常退出即可
# 传入的data是一定是字典，会帮你屏蔽物联网平台、第三方MQTT平台以及页面调试协议的差异
# def <指令处理函数名>(data: dict): 
#   <指令处理代码>

# 对气象传感器设备在upgrade通道下发系统升级指令，指令中携带version系统版本参数
# mqtt topic
#   命令执行结果的反馈数据格式统一为json：{ok: <bool类型，命令是否运行成功>, message: <None或str，如果执行失败则会包含失败的原因>}
#   zzuiot平台：
#       下发topic：g_cmd/<板子Secret>/<下发通道>/<物联网子设备ID>
#           g_cmd/<板子Secret>/upgrade/meteorology_sensor
#       反馈topic：g_events/<板子Secret>/<下发通道>Feedback/<物联网子设备ID>
#           g_events/<板子Secret>/upgradeFeedback/meteorology_sensor
#           (命令的反馈数据需要你在物联网平台建立数据上报通道才能看到)               
#   第三方平台：
#       下发topic：zzu/aiedge/<板子ID>/iot/<物联网子设备ID>/command/<下发通道>
#           zzu/aiedge/<板子ID>/iot/meteorology_sensor/command/upgrade
#       反馈topic：zzu/aiedge/<板子ID>/iot/<物联网子设备ID>/command/<下发通道>/feedback
#           zzu/aiedge/<板子ID>/iot/meteorology_sensor/command/upgrade/feedback
@command(device_id='meteorology_sensor', channel='upgrade')
def upgrade_meteorology_sensor_system(data):
    if data['version'] > 2:  # 模拟指令参数异常，指令执行失败
        raise ValueError('version参数有误，系统无法升级到超过2.0的版本')
    # 做一些气象传感器系统升级操作

# 重启气象传感器
# mqtt topic
#   zzuiot平台：
#       下发topic：g_cmd/<板子Secret>/reboot/meteorology_sensor
#       反馈topic：g_events/<板子Secret>/rebootFeedback/meteorology_sensor
#   第三方平台：
#       下发topic：zzu/aiedge/<板子ID>/iot/meteorology_sensor/command/reboot
#       反馈topic：zzu/aiedge/<板子ID>/iot/meteorology_sensor/command/reboot/feedback
@command(device_id='meteorology_sensor', channel='reboot')
def reboot_meteorology_sensor(data):
    raise NotImplementedError('不支持重启气象传感器')  # 模拟指令执行失败

################
import serial
import os


class SerialInterface:
    def __init__(self, port='/dev/ttyS7', baudrate=9600, timeout=1):
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout
        # self.ser = None
        # self.setstate = None   #0指令模式 1数据收发模式
        # self.setgpio = setgpio
        # self.csgpio = csgpio
        # self.setctl = None
        # self.csctl = None

    def open(self):
        try:
            self.ser = serial.Serial(self.port, self.baudrate, timeout=self.timeout)
        except Exception as e:
            raise RuntimeError(f"打开串口 {self.port} 失败：{e}")

    def close(self):
        if self.ser:
            self.ser.close()

    def write(self, data):
        if not self.ser:
            raise RuntimeError(f"串口 {self.port} 未打开")

        try:
            # self.ser.write(data.encode())
            self.ser.write(data)
        except Exception as e:
            raise RuntimeError(f"发送数据失败：{e}")

    def read(self, length=1024):
        if not self.ser:
            raise RuntimeError(f"串口 {self.port} 未打开")

        try:
            # data = self.ser.read(length).decode()
            data = self.ser.read(length)
            return data
        except Exception as e:
            raise RuntimeError(f"接收数据失败： {e}")

'''
01 设备编号
03 功能码     读取保持寄存器
00 00 00 0A          Data start re
'''        

hex_data = "01 03 00 00 00 0A C5 CD"
byte_data = bytes.fromhex(hex_data)
rs485Dev1 = SerialInterface(port='/dev/ttyS0')

def parse_frame(message,total_length):
    '''
    解析数据帧
    :param message:       list # [1, 3, 20, 1, 196, 0, 239, 0, 0, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 1, 6, 0, 0, 169, 184]
    :param total_length:  int   数据长度
    :return
    '''
    # Rs485dict = {'设备编号' : 0,'风速':0,'风向':0, '温度' : 0, '湿度':0,'气压':0,'分钟雨量':0,'雨量累积':0,'降落物状态':0,'太阳辐射强度':0,'日辐射量':0}
    Rs485dict = {}
    # message = message.hex()
    if  message[0]==0x01 and message[1]==0x03 and message[2]==0x14:
        Rs485dict["device_id"]=message[0]
        Rs485dict["wind_speed"]=(message[3]*256+message[4])/100
        Rs485dict["wind_direction"]=(message[5]*256+message[6])
        Rs485dict["temperature"]=(message[7]*256+message[8])/10
        Rs485dict["humidity"]=(message[9]*256+message[10])/10
        Rs485dict["pressure"]=(message[11]*256+message[12])/10
        Rs485dict["rainfall_by_minute"]=(message[13]*256+message[14])/10
        
        Rs485dict["rainfall_accumulation"]=(message[15]*256+message[16])/10
        Rs485dict["falling_status"]=(message[17]*256+message[18])
        Rs485dict["radiation_intensity"]=(message[19]*256+message[20])/10
        Rs485dict["radiation_by_day"]=(message[21]*256+message[22])/10
        return Rs485dict
    else:
        return Rs485dict

@init
def driver_init():
    rs485Dev1.open()

@release
def driver_release():
    rs485Dev1.close()

# 实验室气象站传感器
@report(interval=1, device_id='lab_meteorology', channel='meteorology')
def report_data():
    rs485Dev1.write(byte_data)
    received_data = rs485Dev1.read()
    return parse_frame(list(received_data), len(received_data))

# if __name__  == '__main__':
#     driver_init()
#     print(report_data())
#     import time
#     time.sleep(2)
#     print(report_data())
#     driver_release()
